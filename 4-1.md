# 4주차 - 포인터 심화

***

## 포인터와 함수

### 인자전달의 기본 방식
* 인자전달의 기본 방식은 값의 __복사__ 이다.
  * 함수 호출 시 전달되는 인자의 값은 매개변수에 복사 된다.
  ```C
  int Func(int num){ ... }
  int main(){
    int age = 17;
    Func(age);    
  }
  ```
  * age의 값은 복사가 되는것 뿐, 매개변수 num과 age는 별개의 것이다.

* 매개변수로 배열을 통체로 넘겨주는 방법은 존재하지 않는다.
  * 즉, 매개변수로 배열을 선언할 수 없다.
  * 대신 배열의 주소값을 넘겨줄 수는 있다.

### 배열을 함수의 인자로 전달하기
  * 배열을 통째로 전달하는게 불가능 하다면, 배열의 주소값을 인자로 전달하여 이를 통해 접근하도록 한다.
    ```C
    void Func(int * paramArr){ ... }
    int main(){
      int arr[3] = {1, 2, 3};
      int * ptr = arr;
      Func(ptr);
    }
    ```
    * ArrayParam.c
      * 함수 내에서는 인자로 전달된 배열의 길이를 계산 할 수 없으니 길이도 같이 전달해줘야 한다.
    * ArrayParamAccess.c

  * 배열을 함수의 인자(매개변수, 파라미터)로 전달 할 경우 다음과 같은 선언도 가능하다.
  ```C
  void A(int * param);
  void A(int param[]);    //위와 동일하다.
  ```

***

## Call-by-value VS Call-by-reference

### Call-by-value
* 값을 전달하는 형태
* 우리가 이때 까지 정의한 함수들 (배열을 함수의 인자로 전달한것은 아니다.)
* CallByValueSwap.c 에서 문제점 지적하기


### Call-by-reference
* 주소 값을 전달하는 형태
  * 주소 값을 전달하니 값의 실제 값을 찾아갈 수 있다.
* CallByRefSwap.c

### scanf 함수 사용시 & 안붙이는 이유!
```C
int num;
scanf("%d", &num);
```
* 변수 num에 값을 채우는 일을 scanf가 한다. 그때 당연히 주소값을 알아야지 찾아가서 넣든 말든 하지 않겠는가.
* scanf함수의 호출도 Call-By-Reference에 해당한다.
```C
char str[30];
scanf("%s", str);   //여기 & 붙으면 안되는 이유
```

***

## 포인터 대상의 const 선언

### const 자료형 * 변수이름
포인터 변수(ptr)가 참고하는 대상(num)의 변경을 허용하지 않는 선언
```C
int num = 20;
const int * ptr = &num;
```
* 포인터 변수를 이용해서 가리키는 변수에 저장된 값을 변경하는 것을 허용하지 않는다.
  ```C
  *ptr = 30   //에러
  ```
* 변수가 직접 변경하는 것은 허용
  ```C
  num = 30   //허용
  ```

### 자료형 * const 변수이름

```C
int * const ptr = &num;
```
* 포인터 변수 ptr은 상수가 된다. 즉 주소값이 저장되면 해당 주소 값 말고 다른 값으로 변경할 수 없다.
```C
int num1=20, num2=30;
int * const ptr = &num1;
ptr = &num2;    //에러
*ptr = 40;      //성공
```

### const 자료형 * const 변수이름

```C
const int * const ptr = &num;

*ptr = 20;    //컴파일 에러
ptr = &age;    //컴파일 에러
```
* 포인터 변수를 이용해서 가리키는 변수에 저장된 값을 변경하는 것을 허용하지 않는다.
* 포인터 변수 ptr은 상수가 된다. 즉 주소값이 저장되면 해당 주소 값 말고 다른 값으로 변경할 수 없다.


### const 선언이 갖는 의미
* const는 그만큼 코드의 안전성이 높아진다.


```C
void Show(const int * arr, int len){
  int i;
  for(i=0;i<len;i++)
    printf("%d ", arr[i]);
}
```
  * const의 의도

```C
void Show(const int * ptr){
  int * rptr = ptr;
  printf("%d \n", *rptr);
  *rptr=20;
}

void main(){
  int num=20;
  int * ptr = &num;
  Show(ptr);
}
```
* 한가지 지적사항

***

## 문제

1. 야구게임
2. 길이가 10인 배열을 선언하고 총 10개의 정수를 입력받아서 홀짝을 구분지어 출력하는 프로그램
    * 일단 홀수부터 출력하고 짝수를 출력
    * 단 10개의 정수는 main함수 내에서 입력
    * 배열 내에 존재하는 홀수만 출력하는 함수와 짝수만 출력하는 함수를 각각 정의
    * 출력 예시
      ```
      홀수 출력 : 1, 3, 5, 7, 9
      짝수 출력 : 2, 4, 6, 8, 0
      ```
3. 10진수 정수를 하나 입력받고 2진수로 변환하여 출력
4. 길이가 10인 배열을 선언 후 10개의 정수를 입력, 입력한 수가 홀수면 배열의 앞부터, 짝수면 배열의 뒤부터 채워나가는 형식
    * 테스트 방법 설명
5. 전달한 영단어가 회문(앞으로 읽으나 뒤로 읽으나 같은 문자 ex.noon, level, bob)인지 아닌지 판단하여 결과를 출력하는 기능의 함수를 정의.
    * 구현의 편의를 위해 대소문자 까지 일치해야 회문으로 인정하는걸로 하자.

***

## 다차원 배열
우리가 이때까지 배운것은 1차원 배열이다. 다차원 배열은 2차원 이상의 배열을 의미한다.
* 1차원 배열은 논리적으로 1차원의 형태를 띈다
* 2차원 배열과 3차원 배열은 논리적으로 각가 2차원과 3차원의 형태를 띈다.
  * 즉 2차원은 배열은 평면구조이고, 3차원 배열은 직육면체 구조의 배열이다.
* 2차원 배열이 사실상 다 차원 배열을 대표한다.

### 2차원 배열 선언

```C
int arr1[3][5];
int arr2[2][6];

TYPE arr[가로길이][세로길이]
```

### 2차원 배열 접근
```C
int arr[3][3];
arr[0][0] = 1;
arr[0][1] = 2;
arr[2][1] = 5;

arr[N-1][M-1] = 20;
```
  * PopuResarch.c

### 2차원 배열 선언과 동시에 초기화
```C
int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};

int arr[3][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

int arr[3][3] = {
  {1},
  {4, 5},
  {7, 8, 9}
};
```
  * 빈곳은 0으로 초기화

* 배열의 크기를 알려주지 않고 초기화 하기
```C
int arr[][] = {1, 2, 3, 4, 5, 6, 7, 8};
```
  * 위의 문제점 말해보기

  ```C
  int arr1[][4] = {1, 2, 3, 4, 5, 6, 7, 8};
  int arr1[][2] = {1, 2, 3, 4, 5, 6, 7, 8};
  ```


* 2차원 배열은 물리적으로도 2차원의 형태로 존재할까? 2차원 배열의 메모리상에서 할당 형태를 생각해보자.


### 3차원 배열
* 3차원 배열 이상은 흔히 사용되지 않는다.
* 3차원 배열은 여러개의 2차원 배열이 모여있는 형태로 이해하는 것이 더 합리적이다.
```C
int record[3][3][2];
```
* 세로와 가로의 길이가 각각 3, 2인 int형 2차원 배열 3개가 겹쳐 있는 것을 이해!

***

## 포인터의 포인터
포인터 변수를 가리키는 또 다른 포인터 변수를 뜻하는 것
* 이중 포인터 혹은 더블 포인터라고 불린다.
```C
int * ptr;      //싱글 포인터
int ** dptr;    //더블 포인터
```

```C
double num = 3,.14;
double * ptr = &num;
double ** dptr = &ptr;
```
  * num과 ptr 모두 변수이지만 저장 하는 값의 종류(유형)이 다르다.
  * ptr 역시 변수기 때문에 주소값을 가지고 있고 이 주소값을 저장할수 있다.(더블 포인터를 통해서)

```C
int num = 7;
int * ptr = &num;
int ** dptr = &ptr;
int *ptr2;

printf("%d %d\n", num, &num);
printf("%d %d\n", ptr, *ptr);
printf("%d %d %d %d\n", &ptr, dptr, *dptr, **dptr);
ptr2 = *dptr;
printf("%d %d \n", ptr2, *ptr2);
```
* 값 예상해  보기
* num에 값을 넣을 수 있는 방법 다 말해보기

### 포인터 변수를 대상으로 한 Call-By-Reference

* 일반 변수를 대상으로 하는 Call-By-Reference
```C
void Swap(int * ptr1, int * ptr2){
  int temp = *ptr1;
  *ptr1 = *ptr2;
  *ptr = temp;
}
```
  * PointerSwapFail.c
    * 포인터 변수 ptr1과 ptr2가 가리키는 대상이 바뀌지 않은 이유
  * 포인터 변수를 대상으로 한 Call-By-Reference 작성해보기.
  * PointerSwapSuccess.c


### 포인터 배열의 포인터 형
```C
int * arr1[20];
double * arr2[30];
```
* `int arr[30]`에서 배열이름 arr은 int형 포인터이다. 그러면 `int * arr1[20]`에서 arr1의 포인터 형은?
* PointerArrayType.c

### 다중포인터 변수
* 포인터 변수를 선언할때 \* 연산자가 둘 이상 사용되어 선언되는 경우 이를 '다중 포인터 변수'라고 한다.
* `int *** tptr`은 이중 포인터를 가리키는 삼중 포인터 이다.
* 삼중 포인터 변수 이상은 많이 사용되지 않는다. 그러니 삼중 포인터 이상을 사용할 때 오용 및 남용은 아닌지 확인해 봐야 한다.


### 포인터의 필요성
* 포인터의 필요성은 자료구조 및 알고리즘 공부시 확실히 느낄 수 있다.
* 데이터의 다양한 표현 및 저장의 중심에는 '포인터'가 존재한다. (C의 경우)
* 하지만 현재로써는 함수 내에서 함수 외부에 선언된 변수에 접근하는 방법을 제시해 준다는 이유 밖에 없다.

***

### 문제
1. 가로의 길이가 9, 세로의 길이가 3인 int형 2차원 배열 구구단 2, 3, 4단을 저장
2. [2][4] 배열A와 [4][2] 배열B를 선언하고 A를 1행을 1\~4, 2행을 5\~8로 초기화 하자. 그리고 A의 값을 사용해서 배열 B를 1열을 1\~4, 2열을 5\~8로 초기화 하자.
3. 다음과 같은 두 개의 int형 포인터 변수와 길이가 5인 int형 배열을 선언
```C
int * maxPtr;
int * minPtr;
int arr[5];
```
MaxAndMin이라는 함수를 정의하고 이를 호출하면서 배열과 두 포인터 변수에 대한 정보를 전달. 그리고 함수 호출이 완료되면 포인터 변수 maxPtr에는 가장 큰 값이 저장된 배열요소의 주소값이, minPtr에는 가장 작은 값이 저장되어 있는 배열 요소의 주소값이 저장되어 있어야한다. 함수에게 정보를 어떻게 전달할지는 알아서 결정해보자!
