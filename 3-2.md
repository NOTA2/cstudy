# 3주차 - 포인터 기초

## 포인터와 배열

### 배열의 이름도 포인터다!

* 배열의 이름은 그 값을 바꿀 수 없는 __'상수 형태의 포인터'__ 이다.
  * ArrayNameType.c
    * int형 배열 요소간 주소 값의 차는 4바이트
* 배열의 이름은 배열의 시작 주소값을 의미하며, 그 형태는 값의 저장이 불가능한 상수이다.

### 포인터 변수와 배열의 이름

|  | 포인터 변수 | 배열의 이름 |
| :--------: | :--------: | :--------: |
| 이름이 존재하는가? | 존재한다. | 존재한다. |
| 무엇을 나타내거나 저장하는가? | 메모리의 주소 값 | 메모리의 주소 값 |
| 주소 값의 변경이 가능한가? | 가능하다. | 불가능하다. |

* 배열의 이름은 가리키는 대상의 변경이 불가능한 상수라는 점에서만 차이를 보인다.

### 1차원 배열이름의 포인터 형

```C
int arr1[5];         // arr1은 int형 포인터 상수
double arr2[5];      // arr2은 double형 포인터 상수
```
* 1차원 배열이름의 포인터 형은 배열의 이름이 가리키는 대상을 기준으로 결정.

### 배열이름을 대상으로 하는 * 연산

* 배열의 이름도 포인터이기 때문에 배열의 이름을 피연산자로 하는 * 연산이 가능하다.
  * ArrayNamePointerOperation.c

```C
int main(){
  int arr[3] = {1,2,3};
  arr[0] +=5;
  arr[1] +=5;
  arr[2] +=5;
}
```
  * arr은 int형 (상수) 포인터이다. 그리고 이러한 포인터를 이용해서 배열에 접근한다.


### 포인터를 배열 이름처럼 사용하기

* 배열의 이름과 포인터 변수는 변수냐 상수냐의 특성적 차이만 존재
* 포인터 변수로 할수 있는 일은 배열 이름으로도 할 수 있고 그 반대도 가능.
  * ArrayNameIsPointer.c


***

## 포인터 연산

포인터를 대상으로 하는 연산은 * 연산 말고도 증가 및 감소연산도 가능하다.

* PointerOperationResult.c
  * 적절한 형태의 초기화는 아님
  * type형 포인터를 대상의로 n의 크기만큼 값을 증감 시, __n * sizeof(TYPE)__ 의 크기만큼 주조 값이 증감한다.
* PointerBaseArrayAccess.c
  * 결과값 예상해 보기
  * 연산자의 우선순위 \*ptr+1과 \*(ptr+1)의 차이점
*
  ```C
  *(++ptr) = 20;    
  *(ptr+1) = 20;   
  ```
    * 차이점 말해보기

* ### __arr[i] == \*(arr+i)__
  ```C
    printf("%d %d %d\n", *(ptr+0), * (ptr+1), *(ptr+2));
    printf("%d %d %d\n", ptr[0], ptr[1], ptr[2]);
    printf("%d %d %d\n", *(arr+0), * (arr+1), *(arr+2));
    printf("%d %d %d\n", arr[0], arr[1], arr[2]);
  ```

***

## 포인터와 문자열
* 문자열의 표현 방식 (마지막에 자동으로 NULL 문자 삽입)
  1. 배열을 이용
  2. char 형 포인터 변수를 이용

### 배열을 이용한 문자열 표현
  ```C
  char str1[] = "My String";
  ```
  * 변수형태의 문자열 선언 (문자열 일부 변경 가능)
  * str1 배열은 문자열 전체를 저장한다. 단, str1은 실제로는 문자 M의 주소를 가리킨다.
  * str1은 계속 문자 M이 저장된 위치를 가리켜야 한다.

### 포인터를 이용한 문자열 표현
  ```C
  char * str2 = "Your String";
  ```
  * 상수 형태의 문자열 선언 (문자열 일부 변경 불가능)
  * str2는 메모리상에 자동으로 저장된 문자열의 첫번째 문자를 단순히 가리키고만있다.
  * str2는 다른 위치를 가리킬 수 있다.
    ```C
      char * str = "Your team";
      str = "Our team";
    ```
  * TwoStringType.c
    * 컴파일러 마다 차이 존재
  * 상수 형태의 문자열 선언의 실행 순서
    * 문자열이 메모리 공간에 저장된 후 주소 값이 반환된다.
    ```C
      WhoAreYou("Hong");
      void WhoAreYou(char * str){...}
    ```


***

## 포인터 배열

포인터 변수로 이루어진 배열, 포인터 변수로 이뤄졌기 때문에 주소 값의 저장이 가능한 배열이다.

```C
int * arr1[20];
double * arr2[30];
```
* PointerArray.c

* #### 문자열을 저장하는 포인터 배열
  * StringArray.c
  * 큰 따옴표로 묶여서 표현되는 문자열은 메모리 공간에 저장된 후 주소 값이 반환된다.

***

### 문제

1. 길이가 5인 int형 배열 선언 및 1~5로 초기화, 배열의 처음을 가리키는 포인터 변수 ptr 선언 후 ptr에 저장된 값을 증가시키는 형태의 연산을 기반으로 배열 요소에 모두 접근하면서 배열 요소의 값을 2씩 증가

2. 이번에는 1과 같지만 ptr의 저장된 값을 변경하지 않으면서 같은 역활을 수행

3. 길이가 6인 int형 배열 선언 및 초기화, 배열에 저장된 값의 순서를 역순이 되도록 변경하는 코드. 단, 배열의 앞과 뒤를 가리키는 포인터 변수 두개를 선언해서 이를 활용하여야 한다.

***

## 포인터와 함수

### 인자전달의 기본 방식
* 인자전달의 기본 방식은 값의 __복사__ 이다.
  * 함수 호출 시 전달되는 인자의 값은 매개변수에 복사 된다.
  ```C
  int Func(int num){ ... }
  int main(){
    int age = 17;
    Func(age);    
  }
  ```
  * age의 값은 복사가 되는것 뿐, 매개변수 num과 age는 별개의 것이다.

* 매개변수로 배열을 통체로 넘겨주는 방법은 존재하지 않는다.
  * 즉, 매개변수로 배열을 선언할 수 없다.
  * 대신 배열의 주소값을 넘겨줄 수는 있다.

### 배열을 함수의 인자로 전달하기
  * 배열을 통째로 전달하는게 불가능 하다면, 배열의 주소값을 인자로 전달하여 이를 통해 접근하도록 한다.
    ```C
    void Func(int * paramArr){ ... }
    int main(){
      int arr[3] = {1, 2, 3};
      int * ptr = arr;
      Func(ptr);
    }
    ```
    * ArrayParam.c
      * 함수 내에서는 인자로 전달된 배열의 길이를 계산 할 수 없으니 길이도 같이 전달해줘야 한다.
    * ArrayParamAccess.c

  * 배열을 함수의 인자(매개변수, 파라미터)로 전달 할 경우 다음과 같은 선언도 가능하다.
  ```C
  void A(int * param);
  void A(int param[]);    //위와 동일하다.
  ```

***

## Call-by-value VS Call-by-reference

### Call-by-value
* 값을 전달하는 형태
* 우리가 이때 까지 정의한 함수들 (배열을 함수의 인자로 전달한것은 아니다.)
* CallByValueSwap.c 에서 문제점 지적하기


### Call-by-reference
* 주소 값을 전달하는 형태
  * 주소 값을 전달하니 값의 실제 값을 찾아갈 수 있다.
* CallByRefSwap.c

### scanf 함수 사용시 & 안붙이는 이유!
```C
int num;
scanf("%d", &num);
```
* 변수 num에 값을 채우는 일을 scanf가 한다. 그때 당연히 주소값을 알아야지 찾아가서 넣든 말든 하지 않겠는가.
* scanf함수의 호출도 Call-By-Reference에 해당한다.
```C
char str[30];
scanf("%s", str);   //여기 & 붙으면 안되는 이유
```

***

## 포인터 대상의 const 선언

### const 자료형 * 변수이름
포인터 변수(ptr)가 참고하는 대상(num)의 변경을 허용하지 않는 선언
```C
int num = 20;
const int * ptr = &num;
```
* 포인터 변수를 이용해서 가리키는 변수에 저장된 값을 변경하는 것을 허용하지 않는다.
  ```C
  *ptr = 30   //에러
  ```
* 변수가 직접 변경하는 것은 허용
  ```C
  num = 30   //허용
  ```

### 자료형 * const 변수이름

```C
int * const ptr = &num;
```
* 포인터 변수 ptr은 상수가 된다. 즉 주소값이 저장되면 해당 주소 값 말고 다른 값으로 변경할 수 없다.
```C
int num1=20, num2=30;
int * const ptr = &num1;
ptr = &num2;    //에러
*ptr = 40;      //성공
```

### const 자료형 * const 변수이름

```C
const int * const ptr = &num;

*ptr = 20;    //컴파일 에러
ptr = &age;    //컴파일 에러
```
* 포인터 변수를 이용해서 가리키는 변수에 저장된 값을 변경하는 것을 허용하지 않는다.
* 포인터 변수 ptr은 상수가 된다. 즉 주소값이 저장되면 해당 주소 값 말고 다른 값으로 변경할 수 없다.


### const 선언이 갖는 의미
* const는 그만큼 코드의 안전성이 높아진다.


```C
void Show(const int * arr, int len){
  int i;
  for(i=0;i<len;i++)
    printf("%d ", arr[i]);
}
```
  * const의 의도

```C
void Show(const int * ptr){
  int * rptr = ptr;
  printf("%d \n", *rptr);
  *rptr=20;
}

void main(){
  int num=20;
  int * ptr = &num;
  Show(ptr);
}
```
* 한가지 지적사항


***

## 난수 만들기

### rand 함수
*
```C
#include<stdlib.h>
int rand(void);  //의사 난수 발생
RAND_MAX         //생성할 수 있는 난수의 최대 값
```
  * 의사난수를 반환
  * 0이상 RAND_MAX 이하의 값 반환
  * 1 이상 100 이하의 값을 반환하는 연습


* rand함수의 문제점
  * 의사 난수를 반환한다.



### srand 함수
```C
#include<stdlib.h>
void srand(unsigned int seed);     //발생할 난수의 씨드 값 지정
```
* rand 함수의 문제점을 해결
* 난수 생성에 필요한 seed 값을 넣어 주는 함수


### time 함수
```C
#include<time.h>
time_t time(time_t * timeptr);
```
* 항상 seed값을 입력받을 수 없으니, 현재 컴퓨터의 시간을 값으로 넣어준다.
  ```C
  srand((int)time(NULL));
  ```

***

## 문제

1. 가위바위보 게임
2. 야구게임
3. 길이가 10인 배열을 선언하고 총 10개의 정수를 입력받아서 홀짝을 구분지어 출력하는 프로그램
    * 일단 홀수부터 출력하고 짝수를 출력
    * 단 10개의 정수는 main함수 내에서 입력
    * 배열 내에 존재하는 홀수만 출력하는 함수와 짝수만 출력하는 함수를 각각 정의
    * 출력 예시
      ```
      홀수 출력 : 1, 3, 5, 7, 9
      짝수 출력 : 2, 4, 6, 8, 0
      ```
4. 10진수 정수를 하나 입력받고 2진수로 변환하여 출력
5. 길이가 10인 배열을 선언 후 10개의 정수를 입력, 입력한 수가 홀수면 배열의 앞부터, 짝수면 배열의 뒤부터 채워나가는 형식
    * 테스트 방법 설명
6. 전달한 영단어가 회문(앞으로 읽으나 뒤로 읽으나 같은 문자 ex.noon, level, bob)인지 아닌지 판단하여 결과를 출력하는 기능의 함수를 정의.
    * 구현의 편의를 위해 대소문자 까지 일치해야 회문으로 인정하는걸로 하자.
