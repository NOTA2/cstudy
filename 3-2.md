# 3주차 - 포인터 기초

## 포인터와 배열

### 배열의 이름도 포인터다!

* 배열의 이름은 그 값을 바꿀 수 없는 __'상수 형태의 포인터'__ 이다.
  * ArrayNameType.c
    * int형 배열 요소간 주소 값의 차는 4바이트
* 배열의 이름은 배열의 시작 주소값을 의미하며, 그 형태는 값의 저장이 불가능한 상수이다.

### 포인터 변수와 배열의 이름

|  | 포인터 변수 | 배열의 이름 |
| :--------: | :--------: | :--------: |
| 이름이 존재하는가? | 존재한다. | 존재한다. |
| 무엇을 나타내거나 저장하는가? | 메모리의 주소 값 | 메모리의 주소 값 |
| 주소 값의 변경이 가능한가? | 가능하다. | 불가능하다. |

* 배열의 이름은 가리키는 대상의 변경이 불가능한 상수라는 점에서만 차이를 보인다.

### 1차원 배열이름의 포인터 형

```C
int arr1[5];         // arr1은 int형 포인터 상수
double arr2[5];      // arr2은 double형 포인터 상수
```
* 1차원 배열이름의 포인터 형은 배열의 이름이 가리키는 대상을 기준으로 결정.

### 배열이름을 대상으로 하는 * 연산

* 배열의 이름도 포인터이기 때문에 배열의 이름을 피연산자로 하는 * 연산이 가능하다.
  * ArrayNamePointerOperation.c

```C
int main(){
  int arr[3] = {1,2,3};
  arr[0] +=5;
  arr[1] +=5;
  arr[2] +=5;
}
```
  * arr은 int형 (상수) 포인터이다. 그리고 이러한 포인터를 이용해서 배열에 접근한다.


### 포인터를 배열 이름처럼 사용하기

* 배열의 이름과 포인터 변수는 변수냐 상수냐의 특성적 차이만 존재
* 포인터 변수로 할수 있는 일은 배열 이름으로도 할 수 있고 그 반대도 가능.
  * ArrayNameIsPointer.c


***

## 포인터 연산

포인터를 대상으로 하는 연산은 * 연산 말고도 증가 및 감소연산도 가능하다.

* PointerOperationResult.c
  * 적절한 형태의 초기화는 아님
  * type형 포인터를 대상의로 n의 크기만큼 값을 증감 시, __n * sizeof(TYPE)__ 의 크기만큼 주조 값이 증감한다.
* PointerBaseArrayAccess.c
  * 결과값 예상해 보기
  * 연산자의 우선순위 \*ptr+1과 \*(ptr+1)의 차이점
*
  ```C
  *(++ptr) = 20;    
  *(ptr+1) = 20;   
  ```
    * 차이점 말해보기

* ### __arr[i] == \*(arr+i)__
  ```C
    printf("%d %d %d\n", *(ptr+0), * (ptr+1), *(ptr+2));
    printf("%d %d %d\n", ptr[0], ptr[1], ptr[2]);
    printf("%d %d %d\n", *(arr+0), * (arr+1), *(arr+2));
    printf("%d %d %d\n", arr[0], arr[1], arr[2]);
  ```

***

## 포인터와 문자열
* 문자열의 표현 방식 (마지막에 자동으로 NULL 문자 삽입)
  1. 배열을 이용
  2. char 형 포인터 변수를 이용

### 배열을 이용한 문자열 표현
  ```C
  char str1[] = "My String";
  ```
  * 변수형태의 문자열 선언 (문자열 일부 변경 가능)
  * str1 배열은 문자열 전체를 저장한다. 단, str1은 실제로는 문자 M의 주소를 가리킨다.
  * str1은 계속 문자 M이 저장된 위치를 가리켜야 한다.

### 포인터를 이용한 문자열 표현
  ```C
  char * str2 = "Your String";
  ```
  * 상수 형태의 문자열 선언 (문자열 일부 변경 불가능)
  * str2는 메모리상에 자동으로 저장된 문자열의 첫번째 문자를 단순히 가리키고만있다.
  * str2는 다른 위치를 가리킬 수 있다.
    ```C
      char * str = "Your team";
      str = "Our team";
    ```
  * TwoStringType.c
    * 컴파일러 마다 차이 존재
  * 상수 형태의 문자열 선언의 실행 순서
    * 문자열이 메모리 공간에 저장된 후 주소 값이 반환된다.
    ```C
      WhoAreYou("Hong");
      void WhoAreYou(char * str){...}
    ```


***

## 포인터 배열

포인터 변수로 이루어진 배열, 포인터 변수로 이뤄졌기 때문에 주소 값의 저장이 가능한 배열이다.

```C
int * arr1[20];
double * arr2[30];
```
* PointerArray.c

* #### 문자열을 저장하는 포인터 배열
  * StringArray.c
  * 큰 따옴표로 묶여서 표현되는 문자열은 메모리 공간에 저장된 후 주소 값이 반환된다.

***

### 문제

1. 길이가 5인 int형 배열 선언 및 1~5로 초기화, 배열의 처음을 가리키는 포인터 변수 ptr 선언 후 ptr에 저장된 값을 증가시키는 형태의 연산을 기반으로 배열 요소에 모두 접근하면서 배열 요소의 값을 2씩 증가

2. 이번에는 1과 같지만 ptr의 저장된 값을 변경하지 않으면서 같은 역활을 수행

3. 길이가 6인 int형 배열 선언 및 초기화, 배열에 저장된 값의 순서를 역순이 되도록 변경하는 코드. 단, 배열의 앞과 뒤를 가리키는 포인터 변수 두개를 선언해서 이를 활용하여야 한다.
