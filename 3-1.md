# 3주차 - 포인터 기초

## 배열

### 배열이란?

* 배열은 다수의 데이터를 저장하고 처리하는 경우 유용하게 사용할 수 있는 것.
```C
int main(){
    int floor101, floor102, floor103, floor104;
    int floor201, floor202, floor203, floor204;
    int floor301, floor302, floor303, floor304;
}
```


* 배열 선언
  * 배열이름
  * 자료형
  * 길이정보
  ```C
  int Array[5];
  ```
    * int형 변수 4개로 이루어진 배열을 선언하되, 배열의 이름은 oneDimArr로 해라!

  ```C
  int arr1[7];
  float arr2[10];
  double arr3[12];

  int len = 20;
  int arr[len];
  ```

* 배열의 접근

  ```C
  arr[0] = 10;
  arr[1] = 20;

  arr[idx] = 20;
  ```
  * 배열 arr의 idx+1번째 요소에 20을 저장!
  * 배열의 위치정보를 명시하는 인덱스 값은 1이 아닌 0부터 시작
  * ArrayAccess.c


* 선언과 동시에 초기화

  ```C
    int arr1[5] = {1,2,3,4,5};
    int arr2[] = {1,2,3,4,5,6,7};
    int arr[5] = {1,2};
  ```
  * ArrayInit.c
    * 배열의 이름을 대상으로 하는 sizeof 연산의 결과로는 '바이트 단위의 배열 크기'가 반환


### 배열을 이용한 문자열 변수의 표현

* char형과 배열을 사용하면 문자열을 저장할 수 있다.
```C
char str[14] = "Good morning!";
char str[] = "good morning!";
```

* 널(NULL) 문자
  * '\0'
  * 문자열의 끝에 자동으로 추가된다.
    * ArrayString.c
  * 아스키 코드값은 0 이다.


* scanf 함수에서 문자열의 입력
  * ReadString.c
    * 문자열을 저장할 때는 &를 넣지 않는다.
    * scanf함수를 통해 받은 문자열도 끝에 널문자가 삽입되어 있다.
      * C언어에서 표현되는 모든 문자열의 끝에는 널 문자가 자동으로 삽입된다.
```C
char arr1[] = {'H', 'i', '~'};         //문자배열
char arr2[] = {'H', 'i', '~', '\0'};  //문자열
```

* NULL 문자의 필요이유
  * 메모리상에서 문자열은 이진 데이터로 저장되기 때문에 문자열의 끝을 알 수 없다
  * NULL 문자는 문자열의 끝을 표시 하는 것이다!

* scanf 함수의 문자열 입력특성
  * ReadString.c 예제에서 He is my friend를 입력
  * 띄어쓰기가 있는 문자열을 입력받는것에 적합하지 않다.


* 지금 소개한 배열은 1차원 배열이다!

***

## 포인터 기초

### 포인터란?

* C언어가 Low 레벨 언어의 특성을 지니게된 장본인
* 포인터를 이용하면 메모리에 직접적인 접근이 가능해진다.

 ```C
 char ch1='A', ch2='Q';
 int num=7;
 ```
 * 변수의 선언과 메모리의 할당
 * int형 변수 num은 어디에 할당되어 있나요?
    * 주소값 역시 정수이다. 이것도 저장이 가능한 값이다
 * __주소값의 저장을 위해 마련된 변수가 바로 '포인터 변수' 이다.__

### 포인터 변수의 선언

 * 정수 7이 저장된 int형 변수 num을 선언하고 이 변수의 주소 값 저장을 위한 포인터 변수 pnum을 선언하자. 그리고 나서 pnum에 변수 num의 주소 값을 저장하자!
 ```C
  int main(){
      int num = 7;
      int * pnum;     //포인터 변수의선언
      pnum = &num;
  }
 ```
  * int * : int형 변수의 주소값을 저장하는 포인터 변수의 선언
  * & 연산자 : 오른쪽에 등장하는 피연산자의 주소 값을 반환하는 연산자
  * __포인터 변수 pnum이 int형 변수 num을 가리킨다.__

 * 포인터 변수 선언
 ```C
type * ptr;
 ```
  * type형 변수의 주소 값을 저장하는 포인터 변수 ptr의 선언
  * 가리키는 변수와 동일한 자료형이여야 한다.

### 포인터 형

* 자료형 : int, char, dobule
* 포인터 형(type) : int * , char * , double *
* 포인터 변수도 값을 저장하는 변수이기 때문에 '포인터 형' 역시 '자료형'의 범주에 포함한다.
```C
type *          //type형 포인터
type * ptr;     //type형 포인터 변수 ptr
```
  * * 의 위치는 상관없다.

### 포인터와 관련있는 연산자 (& , \*)
* &와 \* 연산자는 사용되는 위치에 따라 그 의미가 달라진다.


1. & 연산자
  ```C
  int main(){
      int num = 5;
      int * pnum1 = &num;

      double * pnum2 = &num;    //문제발생의 소지
  }
  ```
  * 주소값을 반환하는 연산자.
  * 피연산자는 변수, 상수는 피연산자가 될 수 없다.
  * 변수의 자료형에 맞지않는 포인터 변수의 선언은 문제가 될 수 있다.

2. \* 연산자
  ```C
  int main(){
      int num =10;
      int * pnum = &num;   //포인터 변수 pnum이 변수 num을 가리키게 하는 문장
      *punm = 20;         //포인터 변수 pnum이 가리키는 메모리 공간인 변수 num에 접근을 해라
      printf("%d", *pnum);    //pnum이 가리키는 변수를 부호 있는 정수로 출력하라
  }
  ```
  * 포인터가 가리키는 메모리를 참조하는 연산자
  * \*는 상황에 따라서 역할이 다르니 잘 알아둬야 한다.
  * PointerOperation.c

### 다양한 포인터 형이 존재하는 이유

```C
return *pnum;
```
  * 값을 반환하려면 pnum이 가리키는 메모리 공간에 접근해서 값을 읽어야 한다.
    * 저장된 주소를 시작으로 몇 바이트를 읽어야 하는가
    * 읽은 데이터는 정수인가? 실수인가?

  * 포인터의 형은 메모리 공간을 참조하는 기준이 된다.
    ```C
    int main(){
        double num = 3.14;
        int * pnum = &num;
        printf("%d", *pnum);
    }
    ```
      * 잘못된 사용

#### 문제
1.
```C
int main(){
    int num = 10;
    int * ptr1 = &num;
    int * ptr2 = ptr1;

    (*ptr1)++;
    (*ptr2)++;
    printf("%d \n", num):
    return 0;
}
```
2. int형 변수 num1, num2를 10, 20으로 선언 및 초기화 하고, int형 포인터 변수 ptr1, ptr2를 선언후 앞에 선언한 int형 변수를 가리키도록 한다. 그리고 포인터 변수를 사용해서 num1을 3증가, num2를 3 감소 시키자. 이제 두 포인터 변수 ptr1과 ptr2가 가리키는 대상을 서로 바꾸자 그 후 마지막으로 ptr1과 ptr2가 가리키는 변수에 저장된 값을 출력!




### 잘못된 포인터의 사용과 널 포인터

* 포인터 변수는 메모리 공간에 접근할 수 있기 때문에 포인터와 관련해서 상당히 주의 해야한다.
  ```C
  int main(){
    int * ptr1;
    *ptr1 = 200;

    int * ptr2 = 123;
    *ptr2=10;
  }
  ```
    * 문제점 말해보기

* 포인터 변수를 초기화 할 값이 없다면 NULL 값으로 초기화 한다.
  ```C
  int main(){
    int * ptr1 = NULL;
    int * ptr2 = 0;         //NULL은 사실상 0을 의미
  }
  ```
    * 0 번지를 가리키는 게 아닌, 아무데도 가리키지 않는다는 뜻
