# 4주차 - 포인터 심화


***

## 다차원 배열과 포인터

* 질문. int형 더블 포인터가 가리킬 수 있는 배열의 종류는 무엇인가요?

### 1차원 배열이름의 포인터 형과 2차원 배열이름의 포인터 형
1. `int arr[10]`에서 arr은 int형 포인터이다.
2. `Func(arr)`을 위해서는 `void Func(int * ptr)` 이와 같이 int형 포인터로 선언되어야 한다.
3. __그러면!__  int형 2차원 배열의 이름은 int형 더블 포인터일까?
4. int형 2차원 배열의 이름을 인자로 전달받으려면 매개변수로 int형 더블포인인터를 전달하면 될까?


```C
void ComplexFunc(int **ptr){...}
int main(){
  int arr2d[2][3];
  complexFunc(arr2d);
}
```
* 이게 맞는 방법일까?
* #### 2차원 배열인 arr2d의 배열이름(arr2d)은 int**형 포인터(int형 더블 포인터)가 아니다!!!
* 그러면 2차원 배열이름의 포인터 형은 무엇일까??

### 2차원 배열 이름이 가리키는 것.
```C
int arr2d[3][3]
```
* 배열이름 arr2d가 가리키는 것은 arr2d[0][0]이다(즉 첫번째 요소이다.)
* #### 그런데 2차원 배열의 경우 arr2d[0], arr2d[1], arr2d[2] 역시 의미를 갖는다.
  * 이들은 각각 1행, 2행, 3행의 첫 번째 요소를 가리킨다.
* 즉, 2차원 배열의 첫번째 요소의 주소값을 출력하는 방법은 3가지이다.
  1. `printf("%p", arr2d)`
  2. `printf("%p", arr2d[0])`
  3. `printf("%p", &arr2d[0][0])`
    * 그러면 arr2d와 arr2d[0]은 같을까?
    * 2DArrayAddress.c

#### 결론
* arr2d는 첫번째 요소를 가리키면서 배열전체를 의미한다.
* arr2d[0]은 첫번째 요소를 가리키지만 1행만을 의미한다.
* 즉 arr2d와 arr2d[0]은 서로 다른 것이다!


### 배열 이름 기반의 포인터 연산
* 배열이름에 1을 더한 결과는?
  1. 1차원 배열의 경우
    ```C
    int arr[5];
    printf("%d %d\n", arr, arr+1);
    ```
    * 배열이름 arr은 int형 포인터 이다. 즉 `arr+sizeof(int)`의 계산결과가 출력된다.
    * 즉 포인터 형을 근거로 하여서 포인터 연산이 된다!

  2. 2차원 배열의 경우
      * 2DArrPointerOp.c
      * 2차원 배열에서 배열이름을 상대로 포인터연산을 하는경우, 연산결과는 각 행의 첫번째 요소의 주소 값이 된다.
        * 당연히 이것도 포인터 형을 근거로 하여서 포인터 연산이 된것이다.
      * 즉, arr1과 arr2는 같은 2차원 배열이지만, 가로길이가 다르다는 이유만으로 포인터 형이 다르다!
      * #### 결론, 2차원 배열이름의 포인터 형은 가로길이에 대한 정보가 있어야한다!!

### 2차원 배열이름의 포인터 형
2차원 배열이름의 포인터 형을 알기위해선 2가지가 필요한다.
1. 가리키는 대상은 무엇인가?
2. 배열이름(포인터)를 대상으로 값을 1 증감시 실제로 얼마나 증감하는가?
  * 즉, 가로의 길이가 몇인가?
```C
int arr[3][4];
```
* 배열이름 arr의 포인터 형은 무엇인가?
  * arr은 가라키는 대상이 int형 변수이고, 포인터 연산시 `sizeof(int)*4`의 크기단위로 값이 증감한다.
* 포인터 변수 선언은 어떻게 하는가?
  ```C
  int (*ptr) [4]
  ```
  1. (\*ptr) : ptr은 포인터!
  2. int : int형 변수를 가리킨다!
  3. [4] : 포인터 연산 시 4칸씩 건너뛴다!

#### 연습하기
1. `char (*arr1)[4];`
2. `double (*arr2)[7];`
3. int형 변수를 가리키면서, 포인터 연산 시 `sizeof(int)* 2`의 크기단위로 값이 증가 및 감소하는 포인터변수 ptr1
4. float형 변수를 가리키면서, 포인터 연산 시 `sizeof(float)* 5`의 크기단위로 값이 증가 및 감소하는 포인터변수 ptr2
5. 아래의 배열들을 선언하고 배열 포인터를 선언한 후 배열 포인터를 사용해서 각각 배열의 요소를 전부 보기 좋게 출력하여라!
```C
	int arr1[2][2]={
		{1, 2}, {3, 4}
	};
	int arr2[3][2]={
		{1, 2}, {3, 4}, {5, 6}
	};
	int arr3[4][2]={
		{1, 2}, {3, 4}, {5, 6}, {7, 8}
	};
```

### 2차원 배열이름의 특성과 주의사항

* #### 배열 포인터 != 포인터 배열
  ```C
  int * whoA[4];      //배열 포인터
  int (*whoB) [4];    //포인터 배열
  ```
  * '에 대한'을 중간에 넣으면 외우기 쉬워요.
  * ArrPtrAndPtrArr.c 보면서 둘의 차이점 이야기 하기

* 2차원 배열을 함수의 인자로 전달하기
  * 우리가 배운것을 토대로 2차원 배열을 인자로 전달해보자
  ```C
  int main(){
    int arr1[2][7];
    double arr2[4][5];
    Func(arr1, arr2);
  }
  ```
  * 위에 해당하는 Func의 함수 원형 말해보기!

* 1차원 배열을 인자로 전달할 때 처럼 다른 방법도 가능하다.
```C
void Func(double (*parr1)[4]){...}
void Func(double parr1[][4]){...}
```
  * 마찬가지로 매개변수로 전달할때만 사용 가능하다.

* 정리. 2DArrParam.c 따라쓰면서 코드 상세 설명하기
  * 배열의 세로길이의 전달이유와 전달 방법

* 2차원 배열에서도 arr[i] == *(arr+i) 는 성립한다.
  ```C
  int arr[3][2] = {{1,2}, {3,4}, {5,6}};
  printf("%d %d %%d %d\n",   arr[2][1], ?????, ?????, ?????)
  ```
    * ????에 들어갈 코드 생각하기! (여러가지 방법이 있다.)
    * 치환!

### 문제
1. 아래를 만족하는 ???를 각각 구해라.
  ```C
  int * arr1[5];
  int * arr2[3][5];

  ??? = arr1;
  ??? = arr2;
  ```

2. 아래를 만족하는 ???를 각각 구해라.
  ```C
  void F1(???, ???){ ... }
  void F2(???, ???){ ... }
  int main(){
    int arr1[3];
    int arr2[4];
    int arr3[3][4];
    int arr4[2][4];

    F1(arr1, arr2);
    F1(arr3, arr4);
  }
  ```

3. 아래를 만족하는 ???를 각각 구해라.
  ```C
  void F1(???, ???){ ... }
  void F2(???, ???){ ... }
  int main(){
    int *arr1[3];
    int *arr2[4][5];
    int **arr3[3];
    int ***arr4[2][4];

    F1(arr1, arr2);
    F1(arr3, arr4);
  }
  ```

4. 다음 예제의 출력결과는 무엇인가?
```C
int main(){
  int arr[3][2] = { {1,2}, {3,4}, {5,6}};
  printf("%d %d \n", arr[1][0], arr[0][1]);
  printf("%d %d \n", *(arr[2]+1), *(arr[1]+1));
  printf("%d %d \n", )
}
```

5. arr[2][2][2] 인 경우, arr[1][0][1]을 대신할 수 있는 문장 5가지 이상 말해보자!


***

## 함수 포인터
* 변수 뿐만 아니라 함수도 바이너리 형태로 메모리 공간에 저장되어서 호출 시 실행된다.
* 그리고 이렇게 메모리에 저장된 함수의 주소값을 저장하는 포인터 변수가 바로 '함수 포인터 변수'이다

### 함수 포인터 변수
* 함수의 이름은 메모리상에 저장된 함수의 주소 값을 의미 (배열이름과 마찬가지)
* 함수의 이름도 상수이다.
* 함수 포인터 변수의 선언은 배열 포인터와 마찬가지로 적절한 함수 포인터의 포인터 형을 결정해야 한다!
```C
int SimpleFunc(int num){ ... }
```
  * 반환형 : int
  * 매개변수 선언 : int num
  * SimpleFunc는 함수의 주소 값을 의미하는 상수형태의 함수 포인터가 된다.
    * 그러면 SimpleFunc의 포인터 형은 무엇일까?

### 함수 포인터의 포인터 형과 선언
* 함수 포인터의 형은 반환형과 배개변수의 선언 형태를 기준으로 구분하자!
```C
int SoSimple1(int year){ ... }
int SoSimple2(int age){ ... }
double SoSimple3(double sz1, double sz2){ ... }
double SoSimple4(double len1, double len2){ ... }
```
  * 함수 포인터의 형을 말해보자!

* 함수 포인터 변수의 선언
  * SoSimple1과 SoSimple2를 가리킬수 있는 포인터 형
  ```C
  int (*fptr) (int)
  ```
    * (*fptr) : fptr은 포인터!
    * int : 반환형이 int인 함수 포인터!
    * (int) : 매개변수 선언이 int 하나인 함수 포인터!
  * SoSimple3의 함수 포인터 형을 적어보자!

```C
int SoSimple1(int year){ ... }

void main(){
  int (*fptr) (int);
  fptr = SoSimple1;
  fptr(3,4);
}
```

* FunctionPointer.c
* UsefulFunctionPointer.c
  * 함수 동작방식에 유연성 제공

***

## void 포인터
형(Type)이 존재하지 않는 void 포인터

```C
void * ptr;
```
* 무엇이든 담을 수 있는 바구니
* VoidTypePointer.c
* 하지만 void 포인터로는 아무것도 할 수 없다.
  * 참조 및 연산이 불가능 하기 때문. 왜?
* void 형 포인터는 '일단 주소 값에만 의미를 두고, 포인터 형은 나중에 결정한다'는 상황일때 유용하게 사용된다.
  * 메모리의 동적 할당과 매우 깊은 관계가 있다.

***

## main 함수로의 인자 전달
```C
int main(void) { ... }
int main(int argc, char * argv[]) { ... }
```

* main 함수를 통해 인자를 전달 할 수 있다!
* ArgcArgv.c

* 프로그램 실행 시 전달인자를 같이 주면 된다.
```
main.out I like you
```


1. int argc
  * 전달된 문자열의 수

2. char * argv[]
  * 이 변수는 어떤 것을 의미할까??
    * char형 더블 포인터
    * char형 포인터 변수로 이루어진 1차원 배열의 이름을 전달 받을 수 있다.
  * ArgvParamType.c

* 인자의 형성 과정
  1. `main.out I like you` 을 통해 프로그램 실행
  2. main 함수로 4개의 문자열이 전달
    * 공백이 문자열을 나누는 기준이 된다.
    * 큰따옴표로 묶으면 공백을 포함하는 문자열이 가능하다.
  3. main 함수는 `main(4, strArr)` 의 형태로 호출된다.
    * strArr은 4개의 문자열을 각각 가리키는 포인터의 배열이며, 배열의 마지막에는 NULL이 있다.
      * 배열의 마지막에 NULL을 넣음으로써 모든 문자열을 출력.
    * ArgvEndNULL.c


***

## 버블 정렬
* 거품이 일어나는 모습과 유사하다고 해서 붙여진 이름
* idx 와 idx+1을 순서대로 비교후 마지막 인덱스는 제외 하고 다시 처음부터 반복

***

## 문제

1. 버블정렬을 사용해서 배열에 저장되어 있는 요소를 내림차순으로 정렬하는 함수(DesSort)를 정의하자. 그리고 이를 이용해서 배열을 내림차순으로 정렬하고 출력하는 프로그램을 짜보자.

2. 길이가 4\*4인 int형 2차원 배열을 선언 아래와 같이 오른쪽 방향으로 90도씩 이동시켜서 결과를 출력시키자.


| 1 | 2 | 3 | 4 |
| :--------: | :--------: | :--------: | :--------: |
| 5 | 6 | 7 | 8 |
| 9 | 10 | 11 | 12 |
| 13 | 14 | 15 | 16 |


| 13 | 9 |5 | 1 |
| :--------: | :--------: | :--------: | :--------: |
| 14 | 10 | 6 | 2 |
| 15 | 11 | 7 | 3 |
| 16 | 12 | 8 | 4 |

| 16 | 15 | 14 |13 |
| :--------: | :--------: | :--------: | :--------: |
| 12 | 11 | 10 | 9 |
| 8 | 7 | 6 | 5 |
| 4 | 3 | 2 | 1 |

| 4 | 8 | 12 | 16 |
| :--------: | :--------: | :--------: | :--------: |
| 3 | 7 | 11 | 15 |
| 2 | 6 | 10 | 14 |
| 1 | 5 | 9 | 13 |

3. 달팽이 배열을 만들어서 출력 하는 프로그램을 만들자. 사용자에게 n을 입력받아서 n\*n의 길이에 해당되는 달팽이 배열을 출력해주자. (단, n<=50)

| 1 | 2 | 3 | 4 |
| :--------: | :--------: | :--------: | :--------: |
| 12 | 13 | 14 | 5 |
| 11 | 16 | 15 | 6 |
| 10 | 9 | 8 | 7 |

| 1 | 2 | 3 | 4 | 5 |
| :--------: | :--------: | :--------: | :--------: | :--------: |
| 16 | 17 | 18 | 19 | 6 |
| 15 | 24 | 25 | 20 | 7 |
| 14 | 23 | 22 | 21 | 8 |
| 13 | 12 | 11 | 10 | 9 |
